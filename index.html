<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forward Diffusion Visualization</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        h1 { margin-bottom: 10px; }
        h2 { margin: 20px 0 10px 0; font-size: 1.2em; }

        .explanation {
            background: #16213e;
            padding: 20px 30px;
            border-radius: 12px;
            margin-bottom: 25px;
            max-width: 800px;
            text-align: left;
        }
        .formula-box {
            font-family: 'Times New Roman', serif;
            font-size: 1.3em;
            text-align: center;
            margin: 15px 0;
            padding: 12px;
            background: #0f3460;
            border-radius: 8px;
        }
        .formula-box.active {
            border: 2px solid #4CAF50;
            background: #1a4a1a;
        }
        .formula-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        .formula-label {
            font-size: 0.85em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        .breakdown {
            font-size: 0.95em;
            line-height: 1.6;
        }
        .breakdown ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .breakdown li { margin: 5px 0; }
        .breakdown p { margin: 10px 0; }

        .variance-note {
            background: #2d1f3d;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 3px solid #9c27b0;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        input[type="range"] {
            width: 250px;
            height: 8px;
        }
        input[type="file"] {
            background: #0f3460;
            padding: 10px;
            border-radius: 8px;
            border: none;
            color: white;
            cursor: pointer;
        }
        .toggle-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        .toggle-btn.active {
            background: #4CAF50;
            color: white;
        }
        .toggle-btn:not(.active) {
            background: #333;
            color: #aaa;
        }
        .t-value {
            font-size: 1.5em;
            font-weight: bold;
            min-width: 80px;
        }

        .grids-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .grid-wrapper {
            text-align: center;
        }
        .grid-wrapper h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
        }
        .pixelGrid {
            display: grid;
            gap: 1px;
            background: #333;
            padding: 1px;
            border-radius: 4px;
        }
        .pixel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            line-height: 1.1;
            width: 32px;
            height: 32px;
        }
        .pixel span { font-size: 7px; }

        .stats {
            margin-top: 10px;
            font-size: 0.85em;
            opacity: 0.8;
        }

        .info {
            margin-top: 20px;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9em;
            max-width: 700px;
        }

        .tab-container {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .tab {
            padding: 10px 20px;
            background: #333;
            border: none;
            color: #aaa;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
        }
        .tab.active {
            background: #16213e;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Forward Diffusion: Adding Gaussian Noise</h1>

    <div class="tab-container">
        <button class="tab active" onclick="showTab('compare')">Compare Formulas</button>
        <button class="tab" onclick="showTab('theory')">Theory</button>
    </div>

    <div id="compare-tab" class="explanation">
        <div class="formula-comparison">
            <div>
                <div class="formula-label">Linear Interpolation (Simple)</div>
                <div class="formula-box" id="linear-formula">
                    x<sub>t</sub> = (1 - t) · x + t · z
                </div>
            </div>
            <div>
                <div class="formula-label">Variance Preserving (Standard)</div>
                <div class="formula-box" id="vp-formula">
                    x<sub>t</sub> = √α<sub>t</sub> · x + √(1-α<sub>t</sub>) · z
                </div>
            </div>
        </div>

        <div class="breakdown">
            <p><strong>Both formulas:</strong></p>
            <ul>
                <li><strong>x</strong> = original image (pixels normalized to [0, 1])</li>
                <li><strong>z ~ N(0, I)</strong> = Gaussian noise (sampled once, same z used throughout)</li>
                <li><strong>t</strong> = time (0 → clean, 1 → pure noise)</li>
                <li><strong>α<sub>t</sub></strong> = noise schedule (here: α<sub>t</sub> = 1 - t)</li>
            </ul>
        </div>

        <div class="variance-note">
            <strong>Key Difference: Variance</strong><br>
            <em>Linear:</em> Var(x<sub>t</sub>) = (1-t)²·Var(x) + t² — variance <strong>dips</strong> in the middle<br>
            <em>VP:</em> Var(x<sub>t</sub>) = α<sub>t</sub>·Var(x) + (1-α<sub>t</sub>) — variance stays <strong>constant</strong> if Var(x)=1
        </div>
    </div>

    <div id="theory-tab" class="explanation" style="display: none;">
        <h2>From Slider to SDE</h2>
        <p>The slider computes x<sub>t</sub> directly. But diffusion models think of it as a <strong>step-by-step process</strong> described by a Stochastic Differential Equation (SDE):</p>

        <div class="formula-box">
            dx = <span style="color: #ff9800;">-½β(t)·x<sub>t</sub></span>·dt + <span style="color: #03a9f4;">√β(t)</span>·dw
        </div>

        <div class="breakdown">
            <p><strong>Two components:</strong></p>
            <ul>
                <li><span style="color: #ff9800;"><strong>Drift:</strong></span> -½β(t)·x<sub>t</sub>·dt — deterministic fading toward zero</li>
                <li><span style="color: #03a9f4;"><strong>Diffusion:</strong></span> √β(t)·dw — random noise injection (dw is Brownian motion)</li>
            </ul>

            <p><strong>Intuition:</strong></p>
            <ul>
                <li><strong>Drift alone:</strong> Image smoothly fades to black</li>
                <li><strong>Diffusion alone:</strong> Image gets buried under static (but still there)</li>
                <li><strong>Both together:</strong> Image fades AND gets replaced by noise → pure N(0,I) at t=1</li>
            </ul>
        </div>

        <div class="variance-note">
            <strong>Why use SDE formulation?</strong><br>
            The reverse process (denoising) is also an SDE! The neural network learns to predict the <em>reverse drift</em>,
            allowing generation from pure noise.
        </div>
    </div>

    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <span>Size:</span>
        <input type="range" id="sizeSlider" min="8" max="64" value="16">
        <span id="sizeValue">16×16</span>
    </div>

    <div class="controls">
        <button class="toggle-btn active" id="showBoth" onclick="setViewMode('both')">Compare Both</button>
        <button class="toggle-btn" id="showLinear" onclick="setViewMode('linear')">Linear Only</button>
        <button class="toggle-btn" id="showVP" onclick="setViewMode('vp')">VP Only</button>
    </div>

    <div class="controls">
        <span>t = </span>
        <input type="range" id="tSlider" min="0" max="1" step="0.01" value="0">
        <span class="t-value" id="tValue">0.00</span>
    </div>

    <div class="grids-container">
        <div class="grid-wrapper" id="linear-wrapper">
            <h3>Linear: x<sub>t</sub> = (1-t)·x + t·z</h3>
            <div class="pixelGrid" id="linearGrid"></div>
            <div class="stats" id="linearStats"></div>
        </div>
        <div class="grid-wrapper" id="vp-wrapper">
            <h3>VP: x<sub>t</sub> = √α·x + √(1-α)·z</h3>
            <div class="pixelGrid" id="vpGrid"></div>
            <div class="stats" id="vpStats"></div>
        </div>
    </div>

    <div class="info">
        Each pixel shows R, G, B values. Watch how variance changes differently for each formula!<br>
        At t=0: original image | At t=1: pure Gaussian noise (both formulas converge)
    </div>

    <script>
        let originalPixels = null;
        let noisePixels = null;
        let gridSize = 16;
        let viewMode = 'both';

        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById('compare-tab').style.display = tab === 'compare' ? 'block' : 'none';
            document.getElementById('theory-tab').style.display = tab === 'theory' ? 'block' : 'none';
            event.target.classList.add('active');
        }

        function setViewMode(mode) {
            viewMode = mode;
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('show' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

            document.getElementById('linear-wrapper').style.display = (mode === 'both' || mode === 'linear') ? 'block' : 'none';
            document.getElementById('vp-wrapper').style.display = (mode === 'both' || mode === 'vp') ? 'block' : 'none';

            // Highlight active formula
            document.getElementById('linear-formula').classList.toggle('active', mode === 'linear');
            document.getElementById('vp-formula').classList.toggle('active', mode === 'vp');
        }

        function gaussianRandom() {
            let u1 = Math.random();
            let u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        function generateNoise(width, height) {
            const noise = [];
            for (let i = 0; i < height; i++) {
                const row = [];
                for (let j = 0; j < width; j++) {
                    row.push([gaussianRandom(), gaussianRandom(), gaussianRandom()]);
                }
                noise.push(row);
            }
            return noise;
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const aspect = img.height / img.width;
                    const width = gridSize;
                    const height = Math.round(gridSize * aspect);

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    const imageData = ctx.getImageData(0, 0, width, height);
                    originalPixels = [];

                    for (let i = 0; i < height; i++) {
                        const row = [];
                        for (let j = 0; j < width; j++) {
                            const idx = (i * width + j) * 4;
                            row.push([
                                imageData.data[idx] / 255,
                                imageData.data[idx + 1] / 255,
                                imageData.data[idx + 2] / 255
                            ]);
                        }
                        originalPixels.push(row);
                    }

                    noisePixels = generateNoise(width, height);
                    updateGrids();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createSampleImage() {
            const height = Math.round(gridSize * 1.3);
            originalPixels = [];

            for (let i = 0; i < height; i++) {
                const row = [];
                for (let j = 0; j < gridSize; j++) {
                    const r = j / (gridSize - 1);
                    const g = i / (height - 1);
                    const b = 1 - (r + g) / 2;
                    row.push([r, g, b]);
                }
                originalPixels.push(row);
            }

            noisePixels = generateNoise(gridSize, height);
            updateGrids();
        }

        function computeVariance(pixels) {
            let sum = 0, sumSq = 0, count = 0;
            for (let i = 0; i < pixels.length; i++) {
                for (let j = 0; j < pixels[i].length; j++) {
                    for (let c = 0; c < 3; c++) {
                        sum += pixels[i][j][c];
                        sumSq += pixels[i][j][c] ** 2;
                        count++;
                    }
                }
            }
            const mean = sum / count;
            return sumSq / count - mean ** 2;
        }

        function updateGrids() {
            if (!originalPixels) return;

            const t = parseFloat(document.getElementById('tSlider').value);
            document.getElementById('tValue').textContent = t.toFixed(2);

            const height = originalPixels.length;
            const width = originalPixels[0].length;

            // Compute alpha for VP formula
            const alpha = 1 - t;
            const sqrtAlpha = Math.sqrt(alpha);
            const sqrtOneMinusAlpha = Math.sqrt(1 - alpha);

            // Build pixel arrays for both formulas
            const linearPixels = [];
            const vpPixels = [];

            for (let i = 0; i < height; i++) {
                const linearRow = [];
                const vpRow = [];
                for (let j = 0; j < width; j++) {
                    const [r, g, b] = originalPixels[i][j];
                    const [nr, ng, nb] = noisePixels[i][j];

                    // Linear: (1-t)*x + t*z
                    linearRow.push([
                        (1 - t) * r + t * nr,
                        (1 - t) * g + t * ng,
                        (1 - t) * b + t * nb
                    ]);

                    // VP: sqrt(alpha)*x + sqrt(1-alpha)*z
                    vpRow.push([
                        sqrtAlpha * r + sqrtOneMinusAlpha * nr,
                        sqrtAlpha * g + sqrtOneMinusAlpha * ng,
                        sqrtAlpha * b + sqrtOneMinusAlpha * nb
                    ]);
                }
                linearPixels.push(linearRow);
                vpPixels.push(vpRow);
            }

            // Render grids
            renderGrid('linearGrid', linearPixels, width, height);
            renderGrid('vpGrid', vpPixels, width, height);

            // Update stats
            const linearVar = computeVariance(linearPixels);
            const vpVar = computeVariance(vpPixels);
            document.getElementById('linearStats').textContent = `Variance: ${linearVar.toFixed(3)}`;
            document.getElementById('vpStats').textContent = `Variance: ${vpVar.toFixed(3)}`;
        }

        function renderGrid(gridId, pixels, width, height) {
            const grid = document.getElementById(gridId);
            grid.style.gridTemplateColumns = `repeat(${width}, 32px)`;
            grid.innerHTML = '';

            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const [noisyR, noisyG, noisyB] = pixels[i][j];

                    const displayR = Math.max(0, Math.min(1, noisyR));
                    const displayG = Math.max(0, Math.min(1, noisyG));
                    const displayB = Math.max(0, Math.min(1, noisyB));

                    const brightness = (displayR + displayG + displayB) / 3;
                    const textColor = brightness < 0.5 ? 'white' : 'black';

                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.backgroundColor = `rgb(${displayR*255}, ${displayG*255}, ${displayB*255})`;
                    pixel.style.color = textColor;
                    pixel.innerHTML = `<span>${noisyR.toFixed(1)}</span><span>${noisyG.toFixed(1)}</span><span>${noisyB.toFixed(1)}</span>`;

                    grid.appendChild(pixel);
                }
            }
        }

        // Event listeners
        document.getElementById('tSlider').addEventListener('input', updateGrids);

        document.getElementById('imageInput').addEventListener('change', function(e) {
            if (e.target.files[0]) {
                loadImage(e.target.files[0]);
            }
        });

        document.getElementById('sizeSlider').addEventListener('input', function(e) {
            gridSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = `${gridSize}×${gridSize}`;
            const fileInput = document.getElementById('imageInput');
            if (fileInput.files[0]) {
                loadImage(fileInput.files[0]);
            } else {
                createSampleImage();
            }
        });

        // Initialize
        createSampleImage();
    </script>
</body>
</html>
